/*******************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.0.
 *
 * You need to add your implementation here to:
 *    - get telemetry data from device/sensor
 *    - set read-only property data
 *    - handle read-write property callback
 *    - process device command
 *
 * Generated Date: Tuesday, August 20, 2019
 *******************************************************************************************/

#include "esp32AzureKit_impl.h"
#include "utilities/digitaltwin_serializer.h"
#include "utilities/deviceinfo_interface.h"
#include "utilities/sensor_interface.h"
#include "sensor_manager.h"

#define Payload_Buffer_Size 256

static bool tempNeedUpdate = true;
static bool humiNeedUpdate = true;
static bool pitchNeedUpdate = true;
static bool rollNeedUpdate = true;
static bool pressureNeedUpdate = true;
static bool altitudeNeedUpdate = true;
static bool magnetXNeedUpdate = true;
static bool magnetYNeedUpdate = true;
static bool magnetZNeedUpdate = true;

static float temp, humidity;
static int pitch = 0, roll = 0;
static float pressure, altitude;
static int magnetX = 0, magnetY = 0, magnetZ = 0;

static int fanSpeed = 50;

void Update_Sensor_Data()
{
    if(tempNeedUpdate && humiNeedUpdate && pitchNeedUpdate && 
       rollNeedUpdate && pressureNeedUpdate && altitudeNeedUpdate && 
       magnetXNeedUpdate && magnetYNeedUpdate && magnetZNeedUpdate)
    {
        temp = get_temperature();
        humidity = get_humidity();
        get_pitch_roll(&pitch, &roll);
        get_pressure_altitude(&pressure, &altitude);
        get_magnetometer(&magnetX, &magnetY, &magnetZ);
        oled_update_humiture(temp, humidity);
        tempNeedUpdate = false;
        humiNeedUpdate = false;
        pitchNeedUpdate = false;
        rollNeedUpdate = false;
        pressureNeedUpdate = false;
        altitudeNeedUpdate = false;
        magnetXNeedUpdate = false;
        magnetYNeedUpdate = false;
        magnetZNeedUpdate = false;
    }
}
double Sensor_Telemetry_ReadTemp()
{
    // TODO: provide implementation here
    Update_Sensor_Data();
    tempNeedUpdate = true;
    return temp;
}

double Sensor_Telemetry_ReadHumid()
{
    // TODO: provide implementation here
    Update_Sensor_Data();
    humiNeedUpdate = true;
    return humidity;
}

double Sensor_Telemetry_ReadLight()
{
    // TODO: provide implementation here
    float ambientLight = get_ambientLight();
    return ambientLight;
}

long Sensor_Telemetry_ReadPitch()
{
    // TODO: provide implementation here
    Update_Sensor_Data();
    pitchNeedUpdate = true;
    return pitch;
}

long Sensor_Telemetry_ReadRoll()
{
    // TODO: provide implementation here
    Update_Sensor_Data();
    rollNeedUpdate = true;
    return roll;
}

double Sensor_Telemetry_ReadPressure()
{
    // TODO: provide implementation here
    Update_Sensor_Data();
    pressureNeedUpdate = true;
    return pressure;
}

double Sensor_Telemetry_ReadAltitude()
{
    // TODO: provide implementation here
    Update_Sensor_Data();
    altitudeNeedUpdate = true;
    return altitude;
}

long Sensor_Telemetry_ReadMagnetX()
{
    // TODO: provide implementation here
    Update_Sensor_Data();
    magnetXNeedUpdate = true;
    return magnetX;
}

long Sensor_Telemetry_ReadMagnetY()
{
    // TODO: provide implementation here
    Update_Sensor_Data();
    magnetYNeedUpdate = true;
    return magnetY;
}

long Sensor_Telemetry_ReadMagnetZ()
{
    // TODO: provide implementation here
    Update_Sensor_Data();
    magnetZNeedUpdate = true;
    return magnetZ;
}

void SendTelemetry_Succeeded_Callback(const char* interfaceName, const char* telemetryName)
{
    // If needed, put your business logic here to handle the confirmation of the delivery for device telemetry on success.

    LogInfo("DigitalTwin successfully delivered telemetry message for %s::%s", interfaceName, telemetryName);
}

void SendTelemetry_Error_Callback(const char* interfaceName, const char* telemetryName)
{
    // If needed, put your business logic here to handle the confirmation of the delivery for device telemetry on failure.

    LogInfo("DigitalTwin failed to deliver telemetry message for %s::%s", interfaceName, telemetryName);
}

void ReportProperty_Succeeded_Callback(const char* interfaceName, const char* propertyName)
{
    // If needed, put your business logic here to handle the result callback reporting property on success.

    LogInfo("DigitalTwin successfully report writable property for %s::%s", interfaceName, propertyName);
}

void ReportProperty_Error_Callback(const char* interfaceName, const char* propertyName)
{
    // If needed, put your business logic here to handle the result callback of reporting property on failure.

    LogInfo("DigitalTwin failed to report writable property for %s::%s", interfaceName, propertyName);
}

char* Deviceinfo_Property_GetManufacturer()
{
    // TODO: provide implementation here
    return "Espressif";
}

char* Deviceinfo_Property_GetModel()
{
    // TODO: provide implementation here
    return "esp32 azure development kit";
}

char* Deviceinfo_Property_GetSwVersion()
{
    // TODO: provide implementation here
    return "software-1.0.0";
}

char* Deviceinfo_Property_GetOsName()
{
    // TODO: provide implementation here
    return "FreeRTOS";
}

char* Deviceinfo_Property_GetProcessorArchitecture()
{
    // TODO: provide implementation here
    return "32-bit";
}

char* Deviceinfo_Property_GetProcessorManufacturer()
{
    // TODO: provide implementation here
    return "Xtensa";
}

int Deviceinfo_Property_GetTotalStorage()
{
    // TODO: provide implementation here
    return 16;
}

int Deviceinfo_Property_GetTotalMemory()
{
    // TODO: provide implementation here
    return 8;
}

bool Sensor_Property_FanSpeedCallback(double fanSpeed)
{
    // TODO: provide implementation here
    LogInfo("FanSpeed property new value: %f", fanSpeed);
    return true;
}

bool Sensor_Property_TempThresholdCallback(double tempThreshold)
{
    // TODO: provide implementation here
    LogInfo("TempThreshold property new value: %f", tempThreshold);
    return true;
}

DIGITALTWIN_COMMAND_RESULT Sensor_Command_Echo(char* displayedValue, char** response, unsigned int* statusCode)
{
    // TODO: provide implementation here
    // You need to process the device command, and set the command response and statusCode correspondingly.
    // Finally, return DIGITALTWIN_COMMAND_OK if the command execution succeeded, or 'DIGITALTWIN_COMMAND_ERROR' on failure.

    LogInfo("Parameter: displayedValue = %s", displayedValue);
    oled_show_message(displayedValue);
    char* responseData = "Execute echo successfully";
    *response = (char*)calloc(strlen(responseData) + 1, sizeof(char));
    strncpy(*response, responseData, strlen(responseData));

    *statusCode = 200;
    LogInfo("Device executed 'echo' command successfully");
    return DIGITALTWIN_COMMAND_OK;
}

DIGITALTWIN_COMMAND_RESULT Sensor_Command_StartFan(unsigned int* statusCode)
{
    // TODO: provide implementation here

    *statusCode = 200;
    start_motor_with_speed(fanSpeed);
    LogInfo("Execute 'startFan' command successfully");
    return DIGITALTWIN_COMMAND_OK;
}

DIGITALTWIN_COMMAND_RESULT Sensor_Command_StopFan(unsigned int* statusCode)
{
    // TODO: provide implementation here

    *statusCode = 200;
    stop_motor();
    LogInfo("Execute 'stopFan' command successfully");
    return DIGITALTWIN_COMMAND_OK;
}

